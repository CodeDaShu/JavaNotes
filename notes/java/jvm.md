
<!-- TOC -->
- [一、运行时内存区域](#一运行时内存区域)
  - [程序计数器](#程序计数器)
  - [栈](#栈)
  - [堆](#堆)
  - [方法区](#方法区)
  - [运行时常量池](#运行时常量池)
  - [直接内存](#直接内存)
  - [线程隔离和线程共享](#线程隔离和线程共享)
- [二、垃圾回收与算法](#二垃圾回收与算法)
- [三、引用类型](#三引用类型)
- [四、类加载机制](#四类加载机制)
<!-- TOC -->


# 一、运行时内存区域

JVM 运行时数据区域大致可以分为：程序计数器、虚拟机栈、本地方法栈、堆区、元空间、运行时常量池、直接内存等区域；就是下面这个样子的：

![Java 运行时数据区域](https://github.com/CodeDaShu/JavaNotes/blob/master/img/JVM/JVM-1.jpg)

其中有些区域，随着 JDK 版本的升级不断调整，例如：

*   JDK 1.6，字符串常量池位于永久代的运行时常量池中；
*   JDK 1.7，字符串常量池从永久代剥离，放入了堆中；
*   JDK 1.8，元空间取代了永久代，并且放入了本地内存（Native memory）中。

## 程序计数器

## 栈

## 堆

## 方法区

## 运行时常量池

## 直接内存

## 线程隔离和线程共享

### 线程私有

![线程私有](https://github.com/CodeDaShu/JavaNotes/blob/master/img/JVM/JVM-private.jpg)

#### 1. 程序计数器

一个 CPU 在某个时间点，只能做一件事情，在多线程的情况下，CPU 运行时间被划分成若干个时间片，分配给各个线程执行；
程序计数器的作用就是记录当前线程执行的位置，当线程被切换回来的时候，能够找到该线程上次运行到哪儿了；所以程序计数器一定是线程隔离的。

#### 2. 虚拟机栈和本地方法栈

*   虚拟机栈：每个 Java 方法在执行的同时，会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息；方法的调用过程，就是一个栈帧在 Java 虚拟机栈中入栈和出栈的过程；
*   本地方法栈：和虚拟机栈很类似，区别在于虚拟机栈为 Java 方法服务，本地方法栈为 Native 方法服务；其中 Native 方法可以看做用其它语言（C、C++ 或汇编语言等）编写的方法；
*   HotSpot 虚拟机就选择了将虚拟机栈和本地方法栈合并在了一起；

为了保证线程中的局部变量不被别的线程访问到，所以虚拟机栈和本地方法栈是线程隔离的。

### 线程公有

![线程公有](https://github.com/CodeDaShu/JavaNotes/blob/master/img/JVM/JVM-public.jpg)

#### 1. 堆区
对于堆栈的区别总结一句话：堆中存对象，栈中存基本数据类型和堆中对象的引用；一个对象的大小是可以动态变化的，而引用是固定大小的。
这么看就容易理解堆为什么是线程公有的了，省地儿啊。

#### 2. 元空间区/方法区 
方法区用于存放已被加载的类信息、常量、静态变量、即编译器编译后的代码等。
还有要注意的一点：方法区是 JVM 的规范，在 JDK 1.8 之前，方法区的实现是永久代；从 JDK 1.8 开始 JVM 移除了永久代，使用本地内存来存储元数据并称之为：元空间（Metaspace）。

#### 3. 运行时常量池 
Class 文件中的常量池，会在类加载后被放入这个区域。
另外在 JDK 1.7 之前，字符串常量池就在运行时常量池中，后来字符串常量池放入了堆中，而运行时常量池仍然在方法区（元空间区）中。
有兴趣的朋友可以自己测试一下，以死循环方式创建字符串常量，在 JDK 1.6 里会报永久代 OOM ；在 JDK 1.7 里会报堆区 OOM 。 

#### 4. 直接内存 
也叫做堆外内存，并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。
JDK 1.4 加入的 NIO 类，引入了一种基于通道 ( Channel ) 与缓冲区 ( Buffer ) 的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过堆上的DirectByteBuffer对象对这块内存进行引用和操作。
简单来说，直接内存就是 JVM 内存之外有一块内存区域，我们通过堆上的一个对象可以操作它；具体等讲到 NIO 部分的时候，再回来加深理解。

# 二、垃圾回收与算法

# 三、引用类型

# 四、类加载机制
