<!-- TOC -->
- [一、存储引擎](#一存储引擎)
- [二、索引](#二索引)
- [三、事务](#三事务)
- [四、并发和锁](#四并发和锁)
- [五、数据库中间件](#五数据库中间件)
- [六、分库分表](#六分库分表)
- [七、CAP](#七CAP)
<!-- TOC -->

# 一、存储引擎

# 二、索引

## 索引的基础知识

MySQL 的基本存储结构是页，大概就是这个样子的：

![innoDB 页结构](https://github.com/CodeDaShu/JavaNotes/blob/master/img/DB/InnoDB.jpg)

**在这里，我们需要了解以下几点（非常重要）：**

*   当我们用 MySQL 的 InnoDB 引擎创建表，有且只能有一个主键；如果我们没有显示地指定之间，那么MySQL 会自动生成一个隐含字段作为主键；
*   聚集索引：以主键创建的索引；聚集索引的叶子节点存储的是表中的数据；
*   非聚集索引：非主键创建的索引；非聚集索引在叶子节点存储的是主键和索引列；使用非聚集索引查询数据，会查询到叶子上的主键，再根据主键查到数据（这个过程叫做回表）。

## 页和页之间、页和数据之间的关系
我们以聚集索引做讲解，页和页之间、以及页和数据之间的关系是这样的：

![页和页的关系](https://github.com/CodeDaShu/JavaNotes/blob/master/img/DB/page-page.jpg)

*   数据页和数据页之间，组成一个双向链表；
*   每个数据页中的记录，是一个单向链表；
*   每个数据页都根据内部的记录生成一个页目录（Page directory），如果是主键的话，可以在页目录中使用二分法快速定位；
*   如果我们根据一个非主键、非索引列进行查询，那么需要遍历双向链表，找到所在的页；再遍历页内的单向链表；如果表内数据很大的话，这样的查询就会很慢。

## B+ Tree 索引的原理
先让我们看看 B+ Tree 索引大概是什么样子（以聚集/主键索引为例）：

![B+Tree索引](https://github.com/CodeDaShu/JavaNotes/blob/master/img/DB/B%2BTree.jpg)

*   假如这时候我们要查询 id = 16 的数据：
*   查询页-1，找到页-2 存储的是小于 30 的数据；
*   查询页-2，找到页-5 存储的是 10~20 的数据；
*   查询页-5，找到 id = 16 的数据。

很显然，没有用索引的时候，需要遍历双向链表来定位对应的页，而有了索引，则可以通过一层层“目录”定位到对应的页上。

## 为什么 B+ Tree 索引会降低新增、修改、删除的速度

*   B+ Tree 是一颗平衡树，如果对这颗树新增、修改、删除的话，会破坏它的原有结构；
*   我们在做数据新增、修改、删除的时候，需要花额外的时间去维护索引；
*   正因为这些额外的开销，导致索引会降低新增、修改、删除的速度。

现在你是否理解了 B+ Tree 索引的原理？

## 为什么官方建议使用自增长主键作为索引？


# 三、事务

# 四、并发和锁

# 五、数据库中间件

## 中间件是什么

干 IT 太累了，我准备辞职开了个烧烤摊，卖羊肉串；

卖羊肉串首先就得有羊肉，于是我就联系了很多养殖场，我又是一个比较负责人的人，为了保证羊肉的质量，我就去考察了一家又一家养殖场，同时我也是个“小气”的人，所以我考察过程中，和对方谈判、比价，最终选了一个养殖场作为我的羊肉供应商，为我提供羊肉。

经营了一阵子，这个养殖场提供的羊肉质量没有以前好了，那么我就重新考察、谈判、比价，如此反复，我投入了大量的时间和精力。

于是我找到了一个信得过的代理公司，约定要羊肉的质量和数量，谈好价钱，以后我只找代理商拿货，具体代理商找的哪家养殖场我不去过问，甚至代理商可以送货上门。

在这个例子里面，卖烧烤就是业务，我的烧烤摊是业务端，养殖场是底层，而这个信得过的代理公司，就是中间件。

数据库中间件：数据库就是底层，我们写的程序就是业务端，数据库中间件就是（和业务无关）的可以实现数据库一些功能的组件。

## 分库分表

当项目的数据量不断增大，单台数据库已经不足以支撑我们的业务量时，通常我们都会采用分库分表的策略。

如果分库分表自己在代码中实现的话，需要管理对个数据源，执行一次查询，需要定位到数据保存在哪个数据源上；当执行插入操作时，又需要确认需要将数据保存在哪个数据源中；

分库分表不仅有 SQL 解析和路由的问题，同时还会有 SQL 改写、并行执行、结果集合并等问题；所以项目经常会使用分库分表的组件，来屏蔽这些复杂的功能。

这类数据库中间件的实现方案基本上有两种：

### 1. Proxy 代理模式

在应用程序和数据库中间，单独部署一个代理层，所有的连接和数据库操作都发给这个代理层，由代理层去做底层的实现。

这样做对开发人员来说，是完全不需要知道下面做了什么的，甚至不需要做任何的代码改造，就可以完成接入；当然 Proxy 代理模式对代理层的高可用提出了很高的挑战，实现起来也很复杂。

![Proxy 代理模式](https://github.com/CodeDaShu/JavaNotes/blob/master/img/DB/Proxy.jpg)

常见的框架有：MyCat（支持 MySQL, Oracle, DB2, PostgreSQL, SQL Server等主流数据库）、Cobar（阿里，已停止维护）、MySQL-Proxy、Atlas（360）、sharing-sphere（当当）等等。

### 2. Client 客户端模式

这种方式需要对现有程序进行改造，项目代码中需要加入分库分表功能的框架，同时也需要对代码中的配置或 SQL 做相应的修改。

Client 的模式，不需要有代理层，也就不需要考虑代理层高可用的问题（去中心化），实现起来也相对简单；当然缺点也很明显，代码的侵入性比较强，并且需要考虑版本升级的问题。

![Client 客户端模式](https://github.com/CodeDaShu/JavaNotes/blob/master/img/DB/Client.jpg)

常见的框架有：TDDL（阿里，新名字DRDS）、zebra（美团）、sharding-jdbc（当当，这个做的也不错）等等。

## 数据增量订阅与消费

这个是基于对数据库增量日志解析，提供增量数据订阅和消费；最有名的是阿里的 Canal。

Canal 通过监听 Mysql 的 binlog 日志来获取数据，binlog 设置为 row 模式，能够获取到每一条新增、删除、修改的日志，同时还能获取到修改前后的数据。

通常我们可以利用这个中间件，实时感知到 Mysql 中的数据变化，将其数据更新到 NoSQL 数据中，比如 MongoDB、ES 等等；通常项目组加入这些非关系数据库，可以减轻数据库查询压力、在分库分表的架构中，还能起到全局查询的作用。

## 其它

除此之外，还有数据库同步中间件，比如阿里的Otter，基于数据库增量日志解析，准实时同步数据，支持两个库都可以写入，写入的数据同步到另外的库；数据库迁移中间件，实现不同数据库之间的数据迁移，比如阿里的yugong，实现了 Oracle 到 Mysql 的数据迁移。

# 六、分库分表

# 七、CAP
